# 调度：多级反馈队列

## KeyPoint
1. MLFQ(Multi=level Feedback Queue)中，任何时刻一个工作只能存在于一个队列中。
2. MLFQ基本规则：
    * 规则1:如果A的优先级>B的优先级，运行A（不运行B）。  
    * 规则2:如果A的优先级=B的优先级，轮转运行A和B。  
    * 规则3:工作进入系统时，放在最高优先级（最上层队列）。
    * 规则4:一旦工作用完了其在某一层中的时间配额(无论中间主动放弃了多少次CPU)，就降低其优先级(移入低一级队列)。  
    * 规则5:经过一段时间S，就将系统中所有工作重新加入最高优先级队列。  
    * 
3. 
## 问
1. 
## 答

## 作业
1. 只用两个工作和两个队列运行几个随机生成的问题。针对每工作计算MLFQ的执行记录。限制每项作业的长度并关闭I/O，让你的生活更轻松。  
    ```terminal
    python mlfq.py -j 2 -n 2 -l 0,10,0:0,10,0 -M 0 
    ```
2. 如何运行调度程序来重现本章中的每个实例?  
    1. 实例1
       ```terminal
       python mlfq.py -n 3 -j 1 -l 0,200,0 -c
       ```
    2. 实例2
       ```terminal
       python mlfq.py -n 3 -l 0,200,0:100,20,0 -c
       ```
    3. 实例3
       ```terminal
        python mlfq.py -n 3 -l 0,10,1:0,100,0 -c
       ```
3. 将如何配置调度程序参数，像轮转调度程序那样工作?  
    ```terminal
    python  mlfq.py -n 1 -l 0,20,0:0,20,0:0,20,0 -c
    ```
4. 设计两个工作的负载和调度程序参数，以便一个工作利用较早的规则 4a 和 4b(用
-S 标志打开)来“愚弄”调度程序，在特定的时间间隔内获得 99%的 CPU。
    ```terminal
    python mlfq.py -n 3 -l 0,100,9:0,100,0 -S -i 1 -c
    ```
5. 给定一个系统，其最高队列中的时间片长度为 10ms，你需要如何频繁地将工作推回 到最高优先级级别(带有-B 标志)，以保证一个长时间运行(并可能饥饿)的工作得到至少
5%的 CPU?  
6. 调度中有一个问题，即刚完成 I/O 的作业添加在队列的哪一端。-I 标志改变了这个
调度模拟器的这方面行为。尝试一些工作负载，看看你是否能看到这个标志的效果。  